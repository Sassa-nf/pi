
POLY = 0x11d
TYPE_POLY = 0x537
TYPE_MASK = 0x5412

VERSION_POLY = 0x1f25

def _centers(w, c):
  cs = [c, w - 7]
  return [(6, c, 2), (c, 6, 2)] + [(x, y, 2) for x in cs
                                             for y in cs]

V6_SZ = 41
V6_CENTERS = [(34, 34, 2)]

V7_SZ = 45
V7_CENTERS = _centers(V7_SZ, 22)

V8_SZ = 49
V8_CENTERS = _centers(V8_SZ, 24)

V9_SZ = 53
V9_CENTERS = _centers(V9_SZ, 26)

VERSIONS = {6: (V6_SZ, V6_CENTERS),
            7: (V7_SZ, V7_CENTERS),
            8: (V8_SZ, V8_CENTERS),
            9: (V9_SZ, V9_CENTERS)}

def clmulb(x, y):
  """Carryless multiplication of two bytes in GF generated by POLY"""
  s = 0
  for i in xrange(7, -1, -1):
    if x & (1 << i):
      s ^= y << i
    if s & (0x100 << i):
      s ^= POLY << i
  return s

exp_x = [1]*256
log_x = [0]*256
for i in xrange(1, 256, 1):
  exp_x[i] = clmulb(2, exp_x[i-1])
  log_x[exp_x[i]] = i

def clmule(x, y):
  if x == 0 or y == 0:
    return 0
  return exp_x[(log_x[x] + log_x[y]) % 0xff]

def gfadd(xs, ys):
  if len(ys) > len(xs):
    t = ys
    ys = xs
    xs = t
  dl = len(xs) - len(ys)
  return xs[0:dl] + [x ^ y for x, y in zip(xs[dl:], ys)]


def clmul(x, ys):
  """Carryless multiplication of polynomial by a single byte"""
  return [clmule(x, y) for y in ys]

def gen_poly(deg):
  """Work out a generator polynomial of a given degree (number of bytes in the
  remainder): (x-a^0)(x-a^1)(x-a^2)..., bearing in mind that a is 2, and
  subtraction is the same as addition in GF(2)"""
  g = [1]
  pow2 = 1
  for i in xrange(deg):
    g = gfadd(clmul(pow2, g), g + [0]) # multiply g by x-2^i
    pow2 <<= 1
    if pow2 & 0x100:
      pow2 ^= POLY
  return g

def remb(d, poly):
  m = -1
  while poly & m != -m:
    d <<= 1
    m <<= 1
  n = -m
  while d & m:
    m <<= 1
    poly <<= 1
  m = -m
  b = d
  while m >= n:
    if d & m:
      d ^= poly
    poly >>= 1
    m >>= 1
  return d | b

def rem(msg, gen):
  gen = gen[1:]
  lg = len(gen)
  m = msg + [0]*lg
  for i in xrange(len(msg)):
    g = clmul(m[i], gen)
    for j in xrange(lg):
      m[i+1+j] ^= g[j]
  return m[-lg:]

def qr_data(msg):
  lm = len(msg) + 2
  if lm <= 68*2:
    ld = 68
    v = 6
    ec_len = 18
  elif lm <= 78*2:
    ld = 78
    v = 7
    ec_len = 20
  elif lm <= 97*2:
    ld = 97
    v = 8
    ec_len = 24
  else:
    if lm > 116*2:
      msg = msg[:116*2-2]
    ld = 116
    v = 9
    ec_len = 30

  d = [0]*(ld*2)
  r = len(msg) # insert length after mode
  d[0] = ((4 << 4) | # Byte mode
          (r >> 4))
  for i in xrange(len(msg)):
    d[i + 1] = ((r << 4) | (msg[i] >> 4)) & 0xff
    r = msg[i]
  d[len(msg)+1] = (r << 4) & 0xff
  for i in xrange(len(msg) + 2, len(d), 1):
    d[i] = 0x11 if i & 1 else 0xec
  b = d[0:ld]
  d = d[ld:]
  g = gen_poly(ec_len)
  e = rem(b, g)
  f = rem(d, g)
  return [x for pair in zip(b, d) + zip(e, f) for x in pair], v

def bgnd(x, y):
  return ((x * y) % 3 + x + y) & 1 == 0

def data_layout(v):
  w, centers = VERSIONS[v]
  x = w - 1
  y = w - 1
  d = 0

  yield x, y
  while x >= 0:
    if d == 0:
      x -= 1
      d = 1
    elif d == 1:
      y -= 1
      x += 1
      d = 0
    elif d == 2:
      x -= 1
      d = 3
    else:
      y += 1
      x += 1
      d = 2

    if y < 0:
      d = 3
      x -= 3
      continue
    if y >= w:
      d = 1
      x -= 3
      continue
    if (y < 9 and (x > w - 9 or x < 9) or # corners
        x < 9 and y > w - 9 or
        any([(x >= cx - r and y >= cy - r and
              x <= cx + r and y <= cy + r) for cx, cy, r in centers]) or
        (v > 6 and y < 6 and x > w - 12) or # version info
        (v > 6 and x < 6 and y > w - 12) or
        (x == 8 and y == w - 8) or # spare dot
        x == 6 or y == 6): # timing
      if x == 6: # this timing is skipped, not trying to align around it
        x = 5
      continue
    yield x, y

def qr_matrix(data, v):
  w, centers = VERSIONS[v]

  # Lay out data first
  # Assuming data is the right size
  mx = data_layout(v)
  for ch in data:
    for i in xrange(7, -1, -1):
      x, y = mx.next()
      if (ch >> i) & 1 ^ bgnd(x, y):
        yield x, y

  # fill the remainder
  for x, y in mx:
    if bgnd(x, y):
      yield x, y

  # EC and Mask
  type_d = remb(0b01111, TYPE_POLY) # Low EC = 01, Mask = 111
  type_d ^= TYPE_MASK
  for i in xrange(7):
    if type_d & (1 << i):
      yield w - 1 - i, 8
      yield 8, i + bool(i > 5)
    if type_d & (1 << (14 - i)):
      yield i + bool(i > 5), 8
      yield 8, w - 1 - i

  yield 8, w - 8 # spare dot

  # Corners, re-sync centers
  for cx, cy, cr in [(3, 3, 3), (3, w - 4, 3), (w - 4, 3, 3)] + centers:
    yield cx, cy
    for dx in [cr] + range(1, cr-1, 1):
      for dy in xrange(-dx, dx, 1):
        yield cx+dx, cy+dy
        yield cx-dx, cy-dy
        yield cx+dy, cy-dx
        yield cx-dy, cy+dx

  # Timing patterns
  for t in xrange(8, w - 8, 2):
    yield 6, t
    yield t, 6


  # Version info
  if v > 6:
    v_info = remb(v, VERSION_POLY)
    for r in xrange(6):
      for c in xrange(3):
        if v_info & 1:
          yield w - 11 + c, r
          yield r, w - 11 + c
        v_info >>= 1

def qr_code(s):
  """Produces a QR Code version 6 .. 9 (41x41 .. 53x53) for a string that is
  assumed to be in ISO-8859-1. If the string is longer than 230 bytes, it is
  trimmed. This generator yields the size of the square, followed by pairs of
  (x, y) for each dot that needs to be black."""
  d, v = qr_data([ord(c) for c in s])
  w, _ = VERSIONS[v]
  yield w
  for pair in qr_matrix(d, v):
    yield pair


def to_mx(qr):
  w = qr.next()
  mx = [[0]*((w + 3) / 4) for i in xrange((w + 1) / 2)]

  def bit_mask(x, y):
    x += 3
    r = y >> 1
    c = x >> 2
    x = 3 - x
    y = 1 - y & 1
    b = (x & 2 | y) << 1 | x & 1
    return r, c, b

  for x, y in qr:
    r, c, b = bit_mask(x, y)
    mx[r][c] |= 1 << b


  return mx

GLYPHS = [u' ',      u'\u2597', u'\u2596', u'\u2584',
          u'\u259D', u'\u2590', u'\u259E', u'\u259F',
          u'\u2598', u'\u259A', u'\u258C', u'\u2599',
          u'\u2580', u'\u259C', u'\u259B', u'\u2588']

def glyphs(c):
  return GLYPHS[c >> 4] + GLYPHS[c & 0xf]

def qr_unicode(mx):
  """Unicode rendering of the QR code. This one looks stretched, so some
  scanners won't read it."""
  return [''.join([glyphs(c) for c in r]) for r in mx]

def qr_dub_unicode(mx):
  """Unicode rendering of the QR code. This one has almost square aspect ratio,
  and ZX code scanner has no difficulty reading these codes. You may need to
  adjust line spacing of your terminal."""
  def dub(c):
    x = c & 0xaa
    y = c & 0x55
    x |= x >> 1
    y |= y << 1
    return x & 0xf0 | y >> 4, y & 0xf | (x & 0xf) << 4

  return [''.join([glyphs(i) for c in r for i in dub(c)]) for r in mx]
