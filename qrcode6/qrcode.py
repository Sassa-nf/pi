import zlib

POLY = 0x11d
TYPE_POLY = 0x537
TYPE_MASK = 0x5412

VERSION_POLY = 0x1f25

def _centers(w, c):
  cs = [c, w - 7]
  return [(6, c, 2), (c, 6, 2)] + [(x, y, 2) for x in cs
                                             for y in cs]

V6_SZ = 41
V6_CENTERS = [(34, 34, 2)]

V7_SZ = 45
V7_CENTERS = _centers(V7_SZ, 22)

V8_SZ = 49
V8_CENTERS = _centers(V8_SZ, 24)

V9_SZ = 53
V9_CENTERS = _centers(V9_SZ, 26)

VERSIONS = {6: (V6_SZ, V6_CENTERS),
            7: (V7_SZ, V7_CENTERS),
            8: (V8_SZ, V8_CENTERS),
            9: (V9_SZ, V9_CENTERS)}

def clmulb(x, y):
  """Carryless multiplication of two bytes in GF generated by POLY"""
  s = 0
  for i in xrange(7, -1, -1):
    if x & (1 << i):
      s ^= y << i
    if s & (0x100 << i):
      s ^= POLY << i
  return s

# Tables for quick multiplication
EXP_X = [1]*256
LOG_X = [0]*256
for i in xrange(1, 256, 1):
  EXP_X[i] = clmulb(2, EXP_X[i-1])
  LOG_X[EXP_X[i]] = i

def clmule(x, y):
  """Quick carryless multiplication using exponentiation tables."""
  if x == 0 or y == 0: # have to guard multiplication by 0, as there is no log(0)
    return 0
  return EXP_X[(LOG_X[x] + LOG_X[y]) % 0xff]

def gfadd(xs, ys):
  """Add two polynomials with coefficients in GF(256)"""
  if len(ys) > len(xs):
    t = ys
    ys = xs
    xs = t
  dl = len(xs) - len(ys)
  return xs[0:dl] + [x ^ y for x, y in zip(xs[dl:], ys)]


def clmul(x, ys):
  """Carryless multiplication of polynomial with coefficients in GF(256) by
  a single byte"""
  return [clmule(x, y) for y in ys]

def gen_poly(deg):
  """Work out a generator polynomial of a given degree (number of bytes in the
  remainder): (x-a^0)(x-a^1)(x-a^2)..., bearing in mind that a is 2, and
  subtraction is the same as addition in GF(2)"""
  g = [1]
  pow2 = 1
  for i in xrange(deg):
    g = gfadd(clmul(pow2, g), g + [0]) # multiply g by x-2^i
    pow2 <<= 1
    if pow2 & 0x100:
      pow2 ^= POLY
  return g

def remb(d, poly):
  """Work out the remainder of dividing d by poly, both being polynomials in
  GF(2) fitting in integers. Returns d with the remainder attached, so you get
  the data with the EC code attached."""
  m = -1
  while poly & m != -m:
    d <<= 1
    m <<= 1
  n = -m
  while d & m:
    m <<= 1
    poly <<= 1
  m = -m
  b = d
  while m >= n:
    if d & m:
      d ^= poly
    poly >>= 1
    m >>= 1
  return d | b

def rem(msg, gen):
  """Work out the remainder of dividing msg by poly, both being polynomials in
  GF(256), generated by POLY."""
  gen = gen[1:]
  lg = len(gen)
  m = msg + [0]*lg
  for i in xrange(len(msg)):
    g = clmul(m[i], gen)
    for j in xrange(lg):
      m[i+1+j] ^= g[j]
  return m[-lg:]

def qr_data(msg):
  """Produce QR data payload for the given message, interleaving with EC codes
  as required for Versions 6 .. 9."""
  lm = len(msg) + 2
  if lm <= 68*2:
    ld = 68
    v = 6
    ec_len = 18
  elif lm <= 78*2:
    ld = 78
    v = 7
    ec_len = 20
  elif lm <= 97*2:
    ld = 97
    v = 8
    ec_len = 24
  else:
    if lm > 116*2:
      msg = msg[:116*2-2]
    ld = 116
    v = 9
    ec_len = 30

  d = [0]*(ld*2)
  r = len(msg) # insert length after mode
  d[0] = ((4 << 4) | # Byte mode
          (r >> 4))
  for i in xrange(len(msg)):
    d[i + 1] = ((r << 4) | (msg[i] >> 4)) & 0xff
    r = msg[i]
  d[len(msg)+1] = (r << 4) & 0xff
  for i in xrange(len(msg) + 2, len(d), 1):
    d[i] = 0x11 if i & 1 else 0xec
  b = d[0:ld]
  d = d[ld:]
  g = gen_poly(ec_len)
  e = rem(b, g)
  f = rem(d, g)
  return [x for pair in zip(b, d) + zip(e, f) for x in pair], v

def bgnd(x, y):
  """Background for Mask 0b111."""
  return ((x * y) % 3 + x + y) & 1 == 0

def data_layout(v):
  """Generator of coordinates for the QR Code version v. Enumerates the area for
  data payload, avoiding corners, re-sync shapes, timing, etc"""
  w, centers = VERSIONS[v]
  x = w - 1
  y = w - 1
  d = 0

  yield x, y
  while x >= 0:
    if d == 0:
      x -= 1
      d = 1
    elif d == 1:
      y -= 1
      x += 1
      d = 0
    elif d == 2:
      x -= 1
      d = 3
    else:
      y += 1
      x += 1
      d = 2

    if y < 0:
      d = 3
      x -= 3
      continue
    if y >= w:
      d = 1
      x -= 3
      continue
    if (y < 9 and (x > w - 9 or x < 9) or # corners
        x < 9 and y > w - 9 or
        any([(x >= cx - r and y >= cy - r and
              x <= cx + r and y <= cy + r) for cx, cy, r in centers]) or
        (v > 6 and y < 6 and x > w - 12) or # version info
        (v > 6 and x < 6 and y > w - 12) or
        (x == 8 and y == w - 8) or # spare dot
        x == 6 or y == 6): # timing
      if x == 6: # this timing is skipped, not trying to align around it
        x = 5
      continue
    yield x, y

def qr_matrix(data, v):
  """Given QR data payload and version, produces QR Code matrix - complete with
  corner, timing, re-sync shapes, version info, masked with background, etc."""
  w, centers = VERSIONS[v]

  # Lay out data first
  # Assuming data is the right size
  mx = data_layout(v)
  for ch in data:
    for i in xrange(7, -1, -1):
      x, y = mx.next()
      if (ch >> i) & 1 ^ bgnd(x, y):
        yield x, y

  # fill the remainder
  for x, y in mx:
    if bgnd(x, y):
      yield x, y

  # EC and Mask
  type_d = remb(0b01111, TYPE_POLY) # Low EC = 01, Mask = 111
  type_d ^= TYPE_MASK
  for i in xrange(7):
    if type_d & (1 << i):
      yield w - 1 - i, 8
      yield 8, i + bool(i > 5)
    if type_d & (1 << (14 - i)):
      yield i + bool(i > 5), 8
      yield 8, w - 1 - i

  yield 8, w - 8 # spare dot

  # Corners, re-sync centers
  for cx, cy, cr in [(3, 3, 3), (3, w - 4, 3), (w - 4, 3, 3)] + centers:
    yield cx, cy
    for dx in [cr] + range(1, cr-1, 1):
      for dy in xrange(-dx, dx, 1):
        yield cx+dx, cy+dy
        yield cx-dx, cy-dy
        yield cx+dy, cy-dx
        yield cx-dy, cy+dx

  # Timing patterns
  for t in xrange(8, w - 8, 2):
    yield 6, t
    yield t, 6


  # Version info
  if v > 6:
    v_info = remb(v, VERSION_POLY)
    for r in xrange(6):
      for c in xrange(3):
        if v_info & 1:
          yield w - 11 + c, r
          yield r, w - 11 + c
        v_info >>= 1

def qr_code(s):
  """Produces a QR Code version 6 .. 9 (41x41 .. 53x53) for a string that is
  assumed to be in ISO-8859-1. If the string is longer than 230 bytes, it is
  trimmed. This generator yields the size of the square, followed by pairs of
  (x, y) for each dot that needs to be black."""
  d, v = qr_data([ord(c) for c in s])
  w, _ = VERSIONS[v]
  yield w
  for pair in qr_matrix(d, v):
    yield pair


def to_mx(qr):
  """Renders QR Code into a "matrix" of bytes. Use with qr_*_unicode to output
  to console."""
  w = qr.next()
  mx = [[0]*((w + 3) / 4) for i in xrange((w + 1) / 2)]

  def bit_mask(x, y):
    x += 3
    r = y >> 1
    c = x >> 2
    x = 3 - x
    y = 1 - y & 1
    b = (x & 2 | y) << 1 | x & 1
    return r, c, b

  for x, y in qr:
    r, c, b = bit_mask(x, y)
    mx[r][c] |= 1 << b


  return mx

# Unicode glyphs for each 4-bit combination.
GLYPHS = [u' ',      u'\u2597', u'\u2596', u'\u2584',
          u'\u259D', u'\u2590', u'\u259E', u'\u259F',
          u'\u2598', u'\u259A', u'\u258C', u'\u2599',
          u'\u2580', u'\u259C', u'\u259B', u'\u2588']

def glyphs(c):
  """Convert byte into a sequence of unicode glyphs."""
  return GLYPHS[c >> 4] + GLYPHS[c & 0xf]

def qr_unicode(mx):
  """Unicode rendering of the QR code. This one looks stretched, so some
  scanners won't read it."""
  return [''.join([glyphs(c) for c in r]) for r in mx]

def qr_dub_unicode(mx):
  """Unicode rendering of the QR code. This one has almost square aspect ratio,
  and ZX code scanner has no difficulty reading these codes. You may need to
  adjust line spacing of your terminal."""
  def dub(c):
    x = c & 0xaa
    y = c & 0x55
    x |= x >> 1
    y |= y << 1
    return x & 0xf0 | y >> 4, y & 0xf | (x & 0xf) << 4

  return [''.join([glyphs(i) for c in r for i in dub(c)]) for r in mx]

def qr_png(s, scale=4):
  """Construct QR Code PNG for a given string with a given scale. Images with
  scale=1 are very small, but although the scanners have no problem reading
  them, a larger image may have a better human factor. Small images can be
  stretched using browser's rendering of HTML (eg specify width="..."), but such
  images appear not crisp (so, again, may look half-cooked).

  Returns the image and its width."""
  def i2b(v):
    return (chr((v >> 24) & 0xff) + chr((v >> 16) & 0xff) +
            chr((v >> 8) & 0xff) + chr(v & 0xff))

  def b2s(b):
    return ''.join([chr(c) for c in b])

  def chunk(name, bs):
    bs = name + bs
    return i2b(len(bs) - 4) + bs + i2b(zlib.crc32(bs))

  mx = qr_code(s)
  w = mx.next()*scale
  # row width in bytes, plus filter method byte
  rw = ((w + 7) >> 3) + 1
  img = [0xff]*rw*w

  # set the filter method to None for all rows
  for y in xrange(w):
    img[y * rw] = 0
  for c, r in mx:
    for y in xrange(r * scale, (r + 1) * scale, 1):
      for x in xrange(c * scale, (c + 1) * scale, 1):
        col = x >> 3
        img[y * rw + 1 + col] &= (1 << (7 - x & 7)) ^ 0xff

  return (i2b(0x89504e47) + i2b(0x0d0a1a0a) + # PNG signature
    # grayscale image with 1 bit per pixel, filtering method 0, no interleaving
         chunk('IHDR', i2b(w) + i2b(w) + '\x01' + i2b(0)) +
         chunk('IDAT', zlib.compress(b2s(img))) +
         chunk('IEND', '')), w
